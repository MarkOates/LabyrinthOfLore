parent_classes:
  - class: LabyrinthOfLore::Shader::Base
    scope: private
    init_with: "obtain_vertex_source(), obtain_fragment_source()"
properties:
  - name: torch_on
    type: bool
    init_with: false
  - name: initialized
    type: bool
    init_with: false
functions:
  - name: initialize
    type: void
    body: |
      if (!initialized) LabyrinthOfLore::Shader::Base::initialize();
      initialized = true;
  - name: toggle_torch
    body: |
      if (!torch_on) set_torch_on();
      else set_torch_off();
  - name: set_torch_on
    body: torch_on = true;
  - name: set_torch_off
    body: torch_on = false;
  - name: activate
    type: void
    body: |
      if (!initialized) throw std::runtime_error("[LabyrinthOfLore::Shader::ClampedColor] Attempting to activate() shader before it has been initialized");
      LabyrinthOfLore::Shader::Base::activate();
      Shader::set_bool("torch_on", torch_on);
  - name: deactivate
    type: void
    body: |
      LabyrinthOfLore::Shader::Base::deactivate();
  - name: obtain_vertex_source
    type: std::string
    static: true
    private: true
    body: |
      static const std::string source = R"DELIM(
        attribute vec4 al_pos;
        attribute vec4 al_color;
        attribute vec2 al_texcoord;
        uniform mat4 al_projview_matrix;
        varying vec4 varying_color;
        varying vec2 varying_texcoord;

        void main()
        {
           varying_color = al_color;
           varying_texcoord = al_texcoord;
           gl_Position = al_projview_matrix * al_pos;
        }
      )DELIM";
      return source;
  - name: obtain_fragment_source
    type: std::string
    static: true
    private: true
    body: |
      static const std::string source = R"DELIM(
        uniform sampler2D al_tex;
        uniform float tint_intensity;
        uniform vec3 tint;
        uniform bool torch_on;
        varying vec4 varying_color;
        varying vec2 varying_texcoord;

        void main()
        {
           vec4 tmp = texture2D(al_tex, varying_texcoord);
           vec4 torch_color = (vec4(0.96, 0.804, 0.2941, 1.0) + vec4(1., 1., 1., 1.)) * 0.7;
           //float noise = 1.0; //noise1(3)* 0.1 + 0.9;

           //bool torch_on = false;
           if (torch_on)
           {
              float depth_value = gl_FragCoord.a;
              //float inverse_tint_intensity = 1.0 - tint_intensity;
              tmp.r = tmp.r * depth_value * torch_color.r;// * noise;
              tmp.g = tmp.g * depth_value * torch_color.g;// * noise;
              tmp.b = tmp.b * depth_value * torch_color.b;// * noise;
              //tmp.a = tmp.a;
           }
           else
           {
              //float depth_value = (gl_FragCoord.a < 0.2) ? 0.0 : gl_FragCoord.a;
              float depth_value = smoothstep(0.05, 0.25, (gl_FragCoord.a * 0.5)) * 0.25; // ? 0.0 : gl_FragCoord.a;
              //float inverse_tint_intensity = 1.0 - tint_intensity;
              tmp.r = tmp.r * depth_value;
              tmp.g = tmp.g * (depth_value + 0.004);
              tmp.b = tmp.b * (depth_value + 0.02);
              //tmp.a = tmp.a;
           }

           gl_FragColor = tmp;
        }
      )DELIM";
      return source;
dependencies:
  - symbol: LabyrinthOfLore::Shader::Base
    headers: [ LabyrinthOfLore/Shader/Base.hpp ]
  - symbol: ALLEGRO_COLOR
    headers: [ allegro5/allegro.h ]
